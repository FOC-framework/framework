package com.foc.bsp;

import java.util.Random;

import javax.swing.SwingUtilities;

import com.foc.Globals;
import com.foc.IExitListener;
import com.foc.IFocEnvironment;

public class CodeMeterChecker implements Runnable, IExitListener{
	
	private IProduct     product             = null;
	private Thread       thread              = null;
	private Object       original            = null;
	private Object       encripted           = null;
	private Random       ran                 = null; 
	private License      license             = null;
	private int          errorCount          = 0;
	private boolean      addedAsExitListener = false;
	private ErrorMessage errorMessage        = null;
	
	private static final int MAX_CHAR          = 90 - 65;     
	private static final int MAX_NUM           = 10     ;
	private static final int MAX_ERROR_ALLOWED = 6      ;
	private static final int SLEEP_DURATION    = 10000  ;//10 sec
	
	public CodeMeterChecker(IProduct product){
		this.product = product;
		ran          = new Random(System.currentTimeMillis());
		thread       = new Thread(this);
		thread.start();
		errorMessage = new ErrorMessage();
	}
	
	public void dispose(){
		//Globals.logString("Disposing CodeMeterChecker!!!");
		if(thread != null){
			thread.interrupt();
			thread = null;
		}
		product = null;
		if(license != null){
			license.dispose();
			license = null;
		}
	}

	private synchronized License getLicense(){
		if(license == null){
			license = new License(this);

			boolean error = false;
			long feature = product.getFirstUnusedFeature(); 
			while(!error && feature > 0 && feature < Long.MAX_VALUE){
				error = isOk(feature);
				feature = feature * 2;
			}
			if(error){
				license.dispose();
				license = null;
			}
		}
		if(!addedAsExitListener && Globals.getApp() != null){
			Globals.getApp().addExitListener(this);
			addedAsExitListener = true;
		}
		return license;
	}	
	
	private boolean isOk(long feature){
		return isOk() && getLicense().hasFeature(feature);
	}

	private boolean isOk(){
		if(errorCount != 0){
			try{
				Thread.sleep((long) (1.5*SLEEP_DURATION));
			}catch(Exception e){
				Globals.logException(e);
			}
		}		
		return errorCount == 0 && getLicense().isHandleOK();
	}
	
	public IProduct getProduct(){
		return product;
	}
	
	private Thread getThread(){
		return thread;
	}
	
	public char newChar(){
		return (char) (ran.nextInt(MAX_CHAR)+65);
	}

	public int newNum(){
		return ran.nextInt(MAX_NUM);
	}
	
	private void regenerateSequence(){
		Random ran = new Random(System.currentTimeMillis());
		
  	StringBuffer newLast = new StringBuffer();		
		for(int i=0; i<47; i++){
			if(ran.nextBoolean()){
				newLast.append(newChar());	
			}else{
				newLast.append(newNum());
			}
		}
		
		original = newLast.toString().getBytes();
	}
	
	private void prepareEncription(){
		regenerateSequence();
		License license = getLicense();
		encripted = license != null ? license.encrypt((byte[]) original) : null;
	}

	private boolean checkDecription(){
		byte[] newSequence = getLicense().decrypt((byte[]) encripted);
		return newSequence == null || !arrayEqual(newSequence, (byte[]) original);
	}
	
	public void run(){
		while(true){
			boolean error = false;			
			try{
				//Globals.logString("Run Begin");
				if(original == null || encripted == null){
					prepareEncription();
				}
				error = original == null || encripted == null;
				if(!error){
					error = checkDecription();
				}
			}catch(Exception e){
				error = true;
				Globals.logString("$3d981#$2");
				//Globals.logException(e);
			}
			
			if(!error){
				//Globals.logString("Periodic Check OK");				
				errorCount = 0;
				prepareEncription();				
			}else{
				errorCount++;
				//Globals.logString("Periodic Check Error : "+errorCount);				
				if(errorCount == 2){
					SwingUtilities.invokeLater(errorMessage);
				}
				if(errorCount == MAX_ERROR_ALLOWED){
					Globals.getApp().exit(true);
				}

				//prepareOriginalAndEncription();
			}
			//Globals.logString("Run End");

			try{
				Thread.sleep(SLEEP_DURATION);
			}catch(Exception e){
				if(e instanceof InterruptedException){
					Globals.logString("Stopped");
				}else{
					Globals.logException(e);
				}
			}
		}
	}
	
	private static CodeMeterChecker codeMeterChecker = null;
	public static synchronized CodeMeterChecker getInstance(){
		if(codeMeterChecker == null || codeMeterChecker.getThread() == null || !codeMeterChecker.getThread().isAlive() || codeMeterChecker.getThread().isInterrupted()){
			codeMeterChecker.dispose();
			codeMeterChecker = null;
		}
		return codeMeterChecker;
	}

	public static synchronized CodeMeterChecker getInstance(IProduct product){
		try{
			if(codeMeterChecker != null){
				if(codeMeterChecker.getThread() == null || !codeMeterChecker.getThread().isAlive() || codeMeterChecker.getThread().isInterrupted()){
					codeMeterChecker.dispose();
					codeMeterChecker = null;
				}
			}
			if(codeMeterChecker == null && product != null){
				codeMeterChecker = new CodeMeterChecker(product);
			}
		}catch(Exception e){
			codeMeterChecker = null;
		}
		return codeMeterChecker;
	}
	
	public static boolean allowAccess(){
		boolean ok = false;
		try{
			ok = getInstance().isOk();
		}catch(Exception e){
			ok = false;
		}
		return ok;
	}
	
	public static boolean allowAccess(long feature){
		boolean ok = false;
		try{
			ok = getInstance().isOk(feature);
		}catch(Exception e){
			ok = false;
		}
		return ok;
	}
	
	/**
	 * Compares two arrays of bytes
	 * 
	 * @param a
	 *            first byte array
	 * @param b
	 *            second byte array
	 * @return true if arrays equal in every byte, otherwise false
	 */
	public static boolean arrayEqual(byte[] a, byte[] b) {
		int len = a.length;
		if (len > b.length)
			len = b.length;
		int i;
		for (i = 0; i < len; ++i) {
			if (a[i] != b[i]) {
				return false;
			}
		}
		return true;
	}
	
	public static boolean isServer(){
		return false;
	}
	

	public void replyToExit() {
		if(codeMeterChecker != null){
			codeMeterChecker.dispose();
			codeMeterChecker = null;
		}
	}
	
	public class ErrorMessage implements Runnable{
		public void run() {
			char messageChars[] = {80,108,101,97,115,101,32,83,65,86,69,32,121,111,117,114,32,119,111,114,107,46,32,84,104,101,32,97,112,112,108,105,99,97,116,105,111,110,32,119,105,108,108,32,101,120,105,116,32,105,110,32,102,101,119,32,115,101,99,111,110,100,115,32,102,111,114,32,115,101,99,117,114,105,116,121,32,114,101,97,115,111,110,115,33};
			
			StringBuffer messageBuffer = new StringBuffer();
			for(int i=0; i<messageChars.length; i++){
				messageBuffer.append(messageChars[i]);
			}
			
			//ASCII ascii = new ASCII("blabla");
			//ascii.writeAsciiCodeArray(System.out);
			Globals.showNotification("Error", messageBuffer.toString(), IFocEnvironment.TYPE_ERROR_MESSAGE);		
		}
	}
	
	public void updateCertifiedTime(){
		Thread trd = new Thread(new Runnable(){
			@Override
			public void run() {
				getLicense().updateCertifiedTime();		
			}
		});
		trd.start();
	}
}
